# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Computes and samples 0 and 1-dimensional laplacian scores.
#'
#' Builds an object to compute and sample values for the combinatorial laplacian score of functions
#' defined on the set of points underlying a given simplicial complex. Takes in data about the complex and
#' its 0- (and possibly 1-) dimensional laplacian to build a scorer. The scorer pushes functions defined on
#' the points underlying the complex to the 0- (or 1-) dimensional skeleton by averaging over the points associated
#' to each complex and evaluates the Rayleigh quotient of the normalized graph laplacean on the pushed function.
#' The scorer can also sample values from the null distribution obtained by shuffling the labels of the underlying points.
#'
#' @name LaplacianScorer
#' @field new Constructs a scorer using  data on the complex and its associated laplacian.\cr\cr
#' \strong{Use} \code{scorer <- new(LaplacianScorer, comb_laplacian, pts_in_vertex, adjacency, one_forms)}\cr\cr
#' \strong{Parameters}\itemize{
#'  \item \code{comb_laplacian}: output of \code{\link{combinatorial_laplacian}}
#'  \item \code{pts_in_vertex}: list of vectors where the i-th vector contains the index of the points associated to the i-th vertex
#'  \item \code{adjacency}: adjacency matrix for 1-skeleton as a sparse matrix
#'  \item \code{one_forms}: boolean indicating if laplacian of one-forms will be computed}
#'
#' @field score Pushes functions defined by rows of funcs to the dim-skeleton by
#' averaging and computes its laplacian score.\cr\cr
#' \strong{Use} \code{scorer$score(funcs, dim)}\cr\cr
#' \strong{Parameters}\itemize{
#'  \item \code{funcs}: functions to be scored as a rows of a dense matrix
#'  \item \code{dim}: dimension of the laplacian (0 or 1)}
#' \strong{Value} Scores of functions as a vector
#'
#' @field sample_scores Takes samples of scores by permuting point labels\cr\cr
#' \strong{Use} \code{scorer$sample_scores(funcs, n_perm, dim, n_cores)}\cr\cr
#' \strong{Parameters}\itemize{
#'  \item \code{funcs}: base functions as rows of a dense matrix
#'  \item \code{n_perm}: number of permutations
#'  \item \code{dim}: dimension of the laplacian
#'  \item \code{n_cores}: number of cores to be used, parallelization requires code to be compiled with \code{openmp} }
#' \strong{Value} Dense matrix with sampled scores where the i-th row has samples for the i-th function
#'
#' @field sample_with_covariate Takes samples of scores of function in tandem with scores of covariates
#' by applying the same permutations of labels to both.
#' \strong{Use} \code{scorer$sample_with_covariate(funcs, cov, n_perm, dim, n_cores)}
#' \strong{Parameters}\itemize{
#'  \item \code{funcs}: base functions as rows of a dense matrix
#'  \item \code{cov}: covariates as rows of a dense matrix
#'  \item \code{n_perm}: number of permutations
#'  \item \code{dim}: dimension of the laplacian
#'  \item \code{n_cores}: number of cores to be used, parallelization requires code to be compiled with \code{openmp} }
#' \strong{Value} A list \code{out} with two elements \itemize{
#'   \item \code{out$func_scores}: a dense matrix with sampled scores where the
#'   i-th row has samples for the i-th function.
#'   \item \code{out$cov_scores}: a dense 3-dimensional array where the position (i, j, k) has the sampled score
#'   of the j-th covariate associated to the k-th sample of the i-th function.}
#'
#' @examples
#' library(RayleighSelection)
#'
#' # Create a simplicial complex and compute the associated 0- and 1-laplacians
#' gy <- nerve_complex(list(c(1,4,6,10), c(1,2,7), c(2,3,8), c(3,4,9,10), c(4,5)))
#' lout <- combinatorial_laplacian(gy, one_forms = TRUE)
#'
#' # Create an associated instance of LaplacianScorer
#' scorer <- new(LaplacianScorer, lout, gy$points_in_vertex, gy$adjacency, TRUE)
#'
#' # Compute the 0-laplacian score of a a function
#' scorer$score(t(as.matrix(c(0,1,1,0,0,0,0,0,0,1))), 0)
#'
#' # Sample scores by shuffling the function
#' scorer$sample_scores(t(as.matrix(c(0,1,1,0,0,0,0,0,0,1))), 10, 0, 1)
#'
#' # Sample scores in tandem with a covariate
#' scorer$sample_with_covariate(t(as.matrix(c(0,1,1,0,0,0,0,0,0,1))),
#'                              t(as.matrix(c(0,1,0,1,0,0,0,0,0,1))), 10, 0, 1)
NULL

#' Computes and samples 0 and 1-dimensional laplacian scorers in ensembles of simplicial complexes.
#'
#' Builds an ensemble of \link{LaplacianScorer} objects that can be used to score functions
#' and to sample scores by shuffling point labels in tandem.
#'
#' @name ScorerEnsemble
#' @field new Constructs a scorer ensemble using lists containing data on the complex
#' and their laplacians.\cr\cr
#' \strong{Use} \code{scorer.ensemple <- new(ScorerEnsemble, comb_laplacian, pts_in_vertex, adjacency, one_forms)}\cr\cr
#' \strong{Parameters}\itemize{
#'  \item \code{comb_laplacian}: List containing outputs of \code{\link{combinatorial_laplacian}}
#'  \item \code{pts_in_vertex}: List of lists of vectors where the i-th vector of the j-th list
#'         contains the index of the points associated to the i-th vertex of the j-th complex
#'  \item \code{adjacency}: List of adjacency matrices for 1-skeleton as a sparse matrix
#'  \item \code{one_forms}: boolean indicating if laplacian of one-forms will be computed}
#'
#' @field score Pushes functions defined by rows of funcs to the dim-skeleton of all complexes by
#' averaging and computes its laplacian score.\cr\cr
#' \strong{Use} \code{scorer$score(funcs, dim)}\cr\cr
#' \strong{Parameters}\itemize{
#'  \item \code{funcs}: functions to be scored as a rows of a dense matrix
#'  \item \code{dim}: dimension of the laplacian (0 or 1)}
#' \strong{Value} Scores of functions as a matrix. The value in position (i,j) is the score of
#'                the i-th function on the j-th complex.
#'
#' @field sample_scores Takes samples of scores by permuting point labels\cr\cr
#' \strong{Use} \code{scorer$sample_scores(funcs, n_perm, dim, n_cores)}\cr\cr
#' \strong{Parameters}\itemize{
#'  \item \code{funcs}: base functions as rows of a dense matrix
#'  \item \code{n_perm}: number of permutations
#'  \item \code{dim}: dimension of the laplacian
#'  \item \code{n_cores}: number of cores to be used, parallelization requires code to be compiled with \code{openmp} }
#' \strong{Value} Dense 3-dimensional array with sampled scores where position (i,j,k) has the score of the j-th
#'                permutation of the i-th function in the k-th complex.
#'
#' @field sample_with_covariate Takes samples of scores of function in tandem with scores of covariates
#' by applying the same permutations of labels to both.
#' \strong{Use} \code{scorer$sample_with_covariate(funcs, cov, n_perm, dim, n_cores)}
#' \strong{Parameters}\itemize{
#'  \item \code{funcs}: base functions as rows of a dense matrix
#'  \item \code{cov}: covariates as rows of a dense matrix
#'  \item \code{n_perm}: number of permutations
#'  \item \code{dim}: dimension of the laplacian
#'  \item \code{n_cores}: number of cores to be used, parallelization requires code to be compiled with \code{openmp} }
#' \strong{Value} A list \code{out} with as many elements as there are complexes in the ensemble. Each element
#'   of the list is itself a list with two elements: \itemize{
#'   \item \code{func_scores}: a dense matrix with sampled scores where the
#'   i-th row has samples for the i-th function.
#'   \item \code{cov_scores}: a dense 3-dimensional array where the position (i, j, k) has the sampled score
#'   of the j-th covariate associated to the k-th sample of the i-th function.}
#'
#' @examples
#' library(RayleighSelection)
#'
#' # Create a simplicial complex and compute the associated 0- and 1-laplacians
#' gy.list <- list(
#'   nerve_complex(list(c(1,4,6,10), c(1,2,7), c(2,3,8), c(3,4,9,10), c(4,5))),
#'   nerve_complex(list(c(1,6,10), c(1,4,2,7), c(2,3,8), c(3,4,9,10), c(4,5)))
#' )
#' lout.list <- lapply(gy.list, combinatorial_laplacian, one_forms = TRUE)
#'
#' # Create an associated instance of ScorerEnsemble
#' scorer.ensemble <- new(
#'   ScorerEnsemble,
#'   lout.list,
#'   lapply(gy.list, function(gy) gy$points_in_vertex),
#'   lapply(gy.list, function(gy) gy$adjacency),
#'   TRUE
#' )
#'
#' # Compute the 0-laplacian scores of a a function
#' scorer.ensemble$score(t(as.matrix(c(0,1,1,0,0,0,0,0,0,1))), 0)
#'
#' # Sample scores by shuffling the function
#' scorer$sample_scores(t(as.matrix(c(0,1,1,0,0,0,0,0,0,1))), 10, 0, 1)
NULL

adjacencyCpp <- function(x, feature_order) {
    .Call('_RayleighSelection_adjacencyCpp', PACKAGE = 'RayleighSelection', x, feature_order)
}

l1down <- function(one_simplices, zero_weights, one_weights) {
    .Call('_RayleighSelection_l1down', PACKAGE = 'RayleighSelection', one_simplices, zero_weights, one_weights)
}

