% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{LaplacianScorer}
\alias{LaplacianScorer}
\title{Computes and samples 0 and 1-dimensional laplacian scores.}
\description{
Builds an object to compute and sample values for the combinatorial laplacian score of functions
defined on the set of points underlying a given simplicial complex. Takes in data about the complex and
its 0- (and possibly 1-) dimensional laplacian to build a scorer. The scorer pushes functions defined on
the points underlying the complex to the 0- (or 1-) dimensional skeleton by averaging over the points associated
to each complex and evaluates the Rayleigh quotient of the normalized graph laplacean on the pushed function.
The scorer can also sample values from the null distribution obtained by shuffling the labels of the underlying points.
}
\section{Fields}{

\describe{
\item{\code{new}}{Constructs a scorer using  data on the complex and its associated laplacian.\cr\cr
\strong{Use} \code{scorer <- new(LaplacianScorer, comb_laplacian, pts_in_vertex, adjacency, one_forms)}\cr\cr
\strong{Parameters}\itemize{
 \item \code{comb_laplacian}: output of \code{\link{combinatorial_laplacian}}
 \item \code{pts_in_vertex}: list of vectors where the i-th vector contains the index of the points associated to the i-th vertex
 \item \code{adjacency}: adjacency matrix for 1-skeleton as a sparse matrix
 \item \code{one_forms}: boolean indicating if laplacian of one-forms will be computed}}

\item{\code{score}}{Pushes functions defined by rows of funcs to the dim-skeleton by
averaging and computes its laplacian score.\cr\cr
\strong{Use} \code{scorer$score(funcs, dim)}\cr\cr
\strong{Parameters}\itemize{
 \item \code{funcs}: functions to be scored as a rows of a dense matrix
 \item \code{dim}: dimension of the laplacian (0 or 1)}
\strong{Value} Scores of functions as a vector}

\item{\code{sample_scores}}{Takes samples of scores by permuting point labels\cr\cr
\strong{Use} \code{scorer$sample_scores(funcs, n_perm, dim, n_cores)}\cr\cr
\strong{Parameters}\itemize{
 \item \code{funcs}: base functions as rows of a dense matrix
 \item \code{n_perm}: number of permutations
 \item \code{dim}: dimension of the laplacian
 \item \code{n_cores}: number of cores to be used, parallelization requires code to be compiled with \code{openmp} }
\strong{Value} Dense matrix with sampled scores where the i-th row has samples for the i-th function}

\item{\code{sample_with_covariate}}{Takes samples of scores of function in tandem with scores of covariates
by applying the same permutations of labels to both.
\strong{Use} \code{scorer$sample_with_covariate(funcs, cov, n_perm, dim, n_cores)}
\strong{Parameters}\itemize{
 \item \code{funcs}: base functions as rows of a dense matrix
 \item \code{cov}: covariates as rows of a dense matrix
 \item \code{n_perm}: number of permutations
 \item \code{dim}: dimension of the laplacian
 \item \code{n_cores}: number of cores to be used, parallelization requires code to be compiled with \code{openmp} }
\strong{Value} A list \code{out} with two elements \itemize{
  \item \code{out$func_scores}: a dense matrix with sampled scores where the
  i-th row has samples for the i-th function.
  \item \code{out$cov_scores}: a dense 3-dimensional array where the position (i, j, k) has the sampled score
  of the j-th covariate associated to the k-th sample of the i-th function.}}
}}

\examples{
library(RayleighSelection)

# Create a simplicial complex and compute the associated 0- and 1-laplacians
gy <- nerve_complex(list(c(1,4,6,10), c(1,2,7), c(2,3,8), c(3,4,9,10), c(4,5)))
lout <- combinatorial_laplacian(gy, one_forms = TRUE)

# Create an associated instance of LaplacianScorer
scorer <- new(LaplacianScorer, lout, gy$points_in_vertex, gy$adjacency, TRUE)

# Compute the 0-laplacian score of a a function
scorer$score(t(as.matrix(c(0,1,1,0,0,0,0,0,0,1))), 0)

# Sample scores by shuffling the function
scorer$sample_scores(t(as.matrix(c(0,1,1,0,0,0,0,0,0,1))), 10, 0, 1)

# Sample scores in tandem with a covariate
scorer$sample_with_covariate(t(as.matrix(c(0,1,1,0,0,0,0,0,0,1))),
                             t(as.matrix(c(0,1,0,1,0,0,0,0,0,1))), 10, 0, 1)
}
