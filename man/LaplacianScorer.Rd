% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{LaplacianScorer}
\alias{LaplacianScorer}
\title{Computes and samples 0 and 1-dimensional laplacian scores.}
\description{
Builds an object to compute and sample values for the combinatorial laplacian score of functions
defined on the set of points underlying a given simplex. Takes in data about the simplex and
its 0- (and possibly 1-) dimensional laplacian to build a scorer. The scorer pushes functions defined on
the points underlying the simplex to the 0- (or 1-) dimensional skeleton by averaging over the points associated
to each simplex and evaluates the Rayleigh quotient of the normalized graph laplacean on the pushed function.
The scorer can also sample values from the null distribution obtained by shuffling the labels of the underlying points.
}
\section{Fields}{

\describe{
\item{\code{new}}{Constructs a scorer using  data on the simplex and its associated laplacian.\cr\cr
\strong{Use} \code{scorer <- new(LaplacianScorer, comb_laplacian, pts_in_vertex, adjacency, one_forms)}\cr\cr
\strong{Parameters}\itemize{
 \item \code{comb_laplacian}: output of \code{\link{combinatorial_laplacian}}
 \item \code{pts_in_vertex}: list of vectors where the i-th vector contains the index of the points associated to the i-th vertex
 \item \code{adjacency}: adjacency matrix for 1-skeleton as a sparse matrix
 \item \code{one_forms}: boolean indicating if laplacian of one-forms will be computed}}

\item{\code{score}}{Pushes functions defined by rows of funcs to the dim-skeleton by
averaging and computes its laplacian score.\cr\cr
\strong{Use} \code{scorer$score(funcs, dim)}\cr\cr
\strong{Parameters}\itemize{
 \item \code{funcs}: functions to be scored as a rows of a dense matrix
 \item \code{dim}: dimension of the laplacian (0 or 1)}
\strong{Value} Scores of functions as a vector}

\item{\code{sample_scores}}{Takes samples of scores by permuting point labels\cr\cr
\strong{Use} \code{scorer$sample_scores(funcs, n_perm, dim, n_cores)}\cr\cr
\strong{Parameters}\itemize{
 \item \code{funcs}: base functions as rows of a dense matrix
 \item \code{n_perm}: number of permutations
 \item \code{dim}: dimension of the laplacian
 \item \code{n_cores}: number of cores to be used, parallelization requires code to be compiled with \code{openmp} }
\strong{Value} Dense matrix with sampled scores where the i-th row has samples for the i-th function}
}}

\examples{
library(RayleighSelection)

# Create a simplicial complex and compute the associated 0- and 1-laplacians
gy <- nerve_complex(list(c(1,4,6,10), c(1,2,7), c(2,3,8), c(3,4,9,10), c(4,5)))
lout <- combinatorial_laplacian(gy, one_forms = TRUE)

# Create an associated instance of LaplacianScorer
scorer <- new(LaplacianScorer, lout, gy$points_in_vertex, gy$adjacency, TRUE)

# Compute the 0-laplacian score of a a function
scorer$score(t(as.matrix(c(0,1,1,0,0,0,0,0,0,1))), 0)

# Sample scores by shuffling the function
scorer$sample_scores(t(as.matrix(c(0,1,1,0,0,0,0,0,0,1))), 10, 0, 1)

}
